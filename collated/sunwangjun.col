//@author: sunwangjun



	/**
	 * origin: .\src\application\Controller.java
	 */

 */
public class Controller extends Application {
    private static final String NAME_TODOS = "To-dos";
    private static final String NAME_EVENTS = "Events";
    private static final String NAME_SEARCH_RESULTS = "search results";
    
    private static final WaveLogger logger = new WaveLogger("Controller");
    
    private static DataStorage dataStorage;    
    private static TaskManager taskManager;
    private static ConfigManager configManager;
    private static UIComponent uiComponent;
    private static Backup backup;
    
	// End of segment: .\src\application\Controller.java





	/**
	 * origin: .\src\application\WaveLogger.java
	 */

 *
 */
public class WaveLogger {
    private static final String consoleOutputList = "consoleOutput.txt";
    
    private final Logger logger;
    private FileHandler fileHandler;
    
    /**
     * Constructs a new logger.
     * Preferably use literal strings for the name of the logger.
     * e.g. "Controller" instead of Controller.class.getName()
     * 
     * @param name the name of the file, without extension.
     */
    public WaveLogger(String name) {
        this.logger = Logger.getLogger(name);
        
        try { // Creates the log directory if it does not exist.
            new File("log").mkdirs();
        } catch (Exception e) {
            logger.log(Level.SEVERE, null, e);
        }
        
        try {
            this.fileHandler = new FileHandler("log\\" + name + ".log");
            this.fileHandler.setFormatter(new SimpleFormatter());
            this.logger.addHandler(this.fileHandler);
        } catch (Exception e) {
            // This will log to the console.
            logger.log(Level.SEVERE, null, e);
        }
        
        this.logger.setLevel(Level.FINEST);
        
        // If not in console output list...
        if (!useConsoleOutput(name)) {
            // Prevents console output.
            this.logger.setUseParentHandlers(false);
        }
    }
    
    private static boolean useConsoleOutput(String name) {
        try {
            Scanner sc = new Scanner(new FileReader(consoleOutputList));
            while (sc.hasNext()) {
                String nameInList = sc.nextLine();
                
                if (name.equals(nameInList)) {
                    sc.close();
                    return true;
                }
            }
            sc.close();
            return false;  
        }
        catch (FileNotFoundException e) {
            return false;
        }      
    }
        
    /**
     * Wraps Logger log method with fine grained level control
     * and message parameters.
     * 
     * @param level the intensity of the message.
     * @param message the message.
     * @param param any objects to pass into message.
     */
    public void log(Level level, String message, Object param) {
        this.logger.log(level, message, param);
    }
    
    /**
     * Wraps Logger log method with fine grained level control.
     * 
     * @param level the intensity of the message.
     * @param message the message.
     */
    public void log(Level level, String message) {
        this.logger.log(level, message);
    }
    
    /**
     * Basic logging log without having to care about levels.
     * 
     * @param message simply the message.
     */
    public void log(String message) {
        this.logger.log(Level.INFO, message);
    }
}

	// End of segment: .\src\application\WaveLogger.java





	/**
	 * origin: .\src\task\ListDisplay.java
	 */

 *
 */
public class ListDisplay {
    protected char TASK_PREFIX = ' ';
    
    protected ArrayList<Comparator<Task>> defaultComparators;
    protected TaskListFilter defaultFilter;
    
    protected ArrayList<Comparator<Task>> additionalComparators;
    protected TaskListFilter additionalFilter;
    
    public ListDisplay() {
        this.defaultComparators = new ArrayList<Comparator<Task>>();
        this.defaultFilter = new TaskListFilter(true); // Does a AND/&& filtering.
        this.additionalComparators = new ArrayList<Comparator<Task>>();
        this.additionalFilter = new TaskListFilter(false);
    }
    
    /**
     * Adds a non-default comparator.
     * @param comparator Comparator<Task>
     */
    public void addComparator(Comparator<Task> comparator) {
        this.additionalComparators.add(comparator);
    }
    
    /**
     * Adds a non-default filter.
     * @param filter TaskFilter
     */
    public void addFilter(TaskFilter filter) {
        this.additionalFilter.add(filter);
    }
    
    /**
     * Replaces the entire task list filter.
     * @param filter TaskListFilter
     */
    public void replaceFilter(TaskListFilter filter) {
        this.additionalFilter = filter;
    }
    
    /**
     * Replaces the entire comparators list.
     * @param comparators ArrayList of Comparator<Task>
     */
    public void replaceComparators(ArrayList<Comparator<Task>> comparators) { 
        this.additionalComparators = comparators;
    }
    
    private static void runComparators(ArrayList<Comparator<Task>> comparators, ArrayList<Task> taskList) {
        ListIterator<Comparator<Task>> li = comparators.listIterator();
        while (li.hasNext()) {
            Collections.sort(taskList, li.next());
        }
    }
    
    /**
     * First filters and sorts using the default filters and comparators, if any.
     * Then filters and sorts using the additional filters and comparators, if any.
     * 
     * @param taskList the list to filter and sort.
     * @param idMapping the Hashtable that maps displayID to internal ID.
     * @return a filtered and sorted ArrayList<Task> 
     */
    public ArrayList<Task> display(ArrayList<Task> taskList, Hashtable<String, Integer> idMapping) {
        ArrayList<Task> filteredTasks = this.defaultFilter.apply(taskList);
        runComparators(this.defaultComparators, filteredTasks);
        
        filteredTasks = this.additionalFilter.apply(filteredTasks);
        runComparators(this.additionalComparators, filteredTasks);

        int i = 1;
        ListIterator<Task> li = filteredTasks.listIterator();
        while (li.hasNext()) {
            Task t = li.next();
            String displayID = this.TASK_PREFIX + "" + i;
            idMapping.put(displayID, t.getID());
            t.setDisplayID(displayID);
            i++;
        }
        
        return filteredTasks;
    }
    
}

/**
 * Events display filters to keep tasks with start dates.
 * Sorts primarily by day, then priority and completion status.
	// End of segment: .\src\task\ListDisplay.java





	/**
	 * origin: .\src\task\ListDisplay.java
	 */

 */
class EventListDisplay extends ListDisplay {    
    public EventListDisplay() {
        super();
        this.TASK_PREFIX = TaskManager.DATED_TASK_PREFIX;
        
        this.defaultFilter.add(new IgnoreTasksDeleted()); // and,
        this.defaultFilter.add(new KeepTasksWithStartDate());
        
        this.defaultComparators.add(new CompletedAtComparator());
        this.defaultComparators.add(new DayPriorityComparator());
    }
}

/**
 * Tasks display filters to keep tasks without start dates.
 * Sorts primarily by completion status, then end dates, then priority and last modified.
	// End of segment: .\src\task\ListDisplay.java





	/**
	 * origin: .\src\task\ListDisplay.java
	 */

 */
class TaskListDisplay extends ListDisplay {    
    public TaskListDisplay() {
        super();
        this.TASK_PREFIX = TaskManager.NORMAL_TASK_PREFIX;
        
        this.defaultFilter.add(new IgnoreTasksDeleted()); // and,
        this.defaultFilter.add(new KeepTasksWithoutStartDate());
        
        this.defaultComparators.add(new ModifiedAtComparator());
        this.defaultComparators.add(new PriorityComparator());
        this.defaultComparators.add(new EndDateComparator());
        this.defaultComparators.add(new CompletedAtComparator());
    }
}
	// End of segment: .\src\task\ListDisplay.java





	/**
	 * origin: .\src\task\Task.java
	 */

 */
public class Task {    
    private static int idCounter = 0;
    
    /* The following fields are not stored. */
    private int id;
    private String displayID;
    private boolean deleted = false;
    
    /* The following attributes are stored. */
    private String description;
    private DateTime date;
    private DateTime endDate;
    private boolean completed;
    private int priority;    
    private DateTime createdAt;
    private DateTime modifiedAt;
    private DateTime completedAt;

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\TaskComparators.java
	 */

 */
class DateComparator implements Comparator<Task> {
    @Override
    public int compare(Task a, Task b) {
        if (a.getDate().isAfter(b.getDate())) {
            return 1; // a is after b, so a comes after b.
        } else if (a.getDate().isBefore(b.getDate())) {
            return -1; // a is before b, so a comes before b.
        } else {
            if (a.getEndDate() == null && b.getEndDate() == null) { // Untested.
                return 0; // both a and b has no end date, do nothing.
            } else if (a.getEndDate() == null) { // Untested.
                return 1; // a has no end date, b has end date, so a comes after b. 
            } else if (a.getEndDate().isAfter(b.getEndDate())) {
                return 1; // a is after b, so a comes after b.
            } else if (a.getEndDate().isBefore(b.getEndDate())) {
                return -1; // a is before b, so a comes before b.
            }
        }
        return 0;
    }
}

	// End of segment: .\src\task\TaskComparators.java





	/**
	 * origin: .\src\task\TaskComparators.java
	 */

 *
 */
class EndDateComparator implements Comparator<Task> {
    @Override
    public int compare(Task a, Task b) {
        if (a.getEndDate() == null && b.getEndDate() == null) {
            return 0;
        } else if (a.getEndDate() == null) {
            return 1; // b has end date, so a comes after b.
        } else if (b.getEndDate() == null) {
            return -1; // a has end date, so a comes before b.
        } else { // Both a and b has end date,
            if (a.getEndDate().isAfter(b.getEndDate())) {
                return 1; // a is after b, a comes after b.
            } else if (a.getEndDate().isBefore(b.getEndDate())) {
                return -1; // a is before b, so a comes before b.
            }
        }
        return 0;
    }
}

	// End of segment: .\src\task\TaskComparators.java





	/**
	 * origin: .\src\task\TaskComparators.java
	 */

 * 
 */
class CompletedAtComparator implements Comparator<Task> {
    @Override
    public int compare(Task a, Task b) {
        if (a.getCompletedAt() == null && b.getCompletedAt() == null) {
            return 0;
        } else if (a.getCompletedAt() == null) {
            return -1; // b has completed date, so a comes before b.
        } else if (b.getCompletedAt() == null) {
            return 1; // a has completed date, so a comes after b.
        } else { // Both a and b has end date,
            if (a.getCompletedAt().isAfter(b.getCompletedAt())) {
                return 1; // a is after b, a comes after b.
            } else if (a.getCompletedAt().isBefore(b.getCompletedAt())) {
                return -1; // a is before b, so a comes before b.
            }
        }
        return 0;
    }
}

	// End of segment: .\src\task\TaskComparators.java





	/**
	 * origin: .\src\task\TaskComparators.java
	 */

 */
class ModifiedAtComparator implements Comparator<Task> {
    @Override
    public int compare(Task a, Task b) {
        if (a.getModifiedAt().isAfter(b.getModifiedAt())) {
            return -1; // a is after b, so a comes after b.
        } else if (a.getModifiedAt().isBefore(b.getModifiedAt())) {
            return 1; // a is before b, so a comes before b.
        }
        return 0;
    }
}

	// End of segment: .\src\task\TaskComparators.java





	/**
	 * origin: .\src\task\TaskComparators.java
	 */

 */
class PriorityComparator implements Comparator<Task> {
    @Override
    public int compare(Task a, Task b) {
        // a is greater priority, a should be before b.
        return b.getPriority() - a.getPriority();
    }
}

	// End of segment: .\src\task\TaskComparators.java





	/**
	 * origin: .\src\task\TaskComparators.java
	 */

 */
class DayPriorityComparator implements Comparator<Task> {
    @Override
    public int compare(Task a, Task b) {
        LocalDate ldtA = a.getDate().toLocalDate();
        LocalDate ldtB = b.getDate().toLocalDate();
        
        if (ldtA.isAfter(ldtB)) {
            return 1; // a is after b, so a comes after b.
        } else if (ldtA.isBefore(ldtB)) {
            return -1; // a is before b, so a comes before b.
        }

        else { // Same day, so sort by priority:
            
            if (a.getPriority() > b.getPriority()) {
                return -1; // a has greater priority, so a comes before b.
            } else if (a.getPriority() < b.getPriority()) {
                return 1; // a has smaller priority, so a comes after b.
            }
            
            // Else, priority is equal, so sort by end date:
            else if (a.getEndDate() == null && b.getEndDate() == null) {
                return 0; // both a and b has no end date, do nothing.
            } else if (a.getEndDate() == null) { // Untested.
                return 1; // a has no end date, b has end date, so a comes after b. 
            } else if (a.getEndDate().isAfter(b.getEndDate())) {
                return 1; // a is after b, so a comes after b.
            } else if (a.getEndDate().isBefore(b.getEndDate())) {
                return -1; // a is before b, so a comes before b.
            }
        }
        return 0;        
    }
}

	// End of segment: .\src\task\TaskComparators.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

 */
class KeepTasksCompleted implements TaskFilter {
    @Override
    public boolean apply(Task t) {
        return t.isCompleted();
    }
}

/**
 * Filter to keep tasks which are completed in the past 24 hours. 
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

 */
class KeepTasksCompletedToday implements TaskFilter {
    private DateTime oneDayAgo;
    public KeepTasksCompletedToday() {
        this.oneDayAgo = new DateTime().minusDays(1);
    }
    
    @Override
    public boolean apply(Task t) {
        return t.getCompletedAt() != null && t.getCompletedAt().isAfter(this.oneDayAgo);
    }
}

/**
 * Filter to keep tasks which are over due. 
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

 */
class KeepTasksOutstanding implements TaskFilter {
    private DateTime now;
    public KeepTasksOutstanding() {
        this.now = new DateTime();
    }
    
    @Override
    public boolean apply(Task t) {
        if (!t.isCompleted()) {
            if (t.getEndDate() != null && t.getEndDate().isBefore(this.now)) {
                return true;
            }
            // There is no end date but only start date, and it is before now.
            else if (t.getEndDate() == null &&
                    t.getDate() != null && t.getDate().isBefore(this.now)) {
                return true;
            }
        }
        return false;
    }
}

/**
 * Filter to keep tasks between a start and end time. 
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

 */
class KeepTasksBetween implements TaskFilter {
    private DateTime start, end;
    /**
     * This constructor uses two specific date times.
     * @param start start Datetime
     * @param end end DateTime
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

     */
    public KeepTasksBetween(DateTime start, DateTime end) {
        this.start = start;
        this.end = end;
    }
    /**
     * This constructor accepts a number to use the current time and number of days later.
     * @param numDays the number of days from the current time to number of days later.
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

     */
    public KeepTasksBetween(int numDays) {
        this.start = new DateTime();
        this.end = new DateTime().plusDays(numDays);
    }
    
    @Override
    public boolean apply(Task t) {
        // There is start date,
        if (t.getDate() != null) {
            // Start date is between requested start and end,
            if (t.getDate().isAfter(this.start) && t.getDate().isBefore(this.end)) {
                return true;
            }
        }
        
        // There is end date,
        if (t.getEndDate() != null) {
            // End date is between requested start and end,
            if (t.getEndDate().isAfter(this.start) && t.getEndDate().isBefore(this.end)) {
                return true;
            }
        }
        
        return false;
    }   
}

/**
 * Filter to keep tasks that contain the keyword. 
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

 */
class KeepTasksWithKeyword implements TaskFilter {
    private String keyword;

    /**
     * @param keyword the String keyword. 
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

     */
    public KeepTasksWithKeyword(String keyword) {
        this.keyword = keyword.toUpperCase();
    }
    
    @Override
    public boolean apply(Task t) {
        String uppercaseDescription = t.getDescription().toUpperCase();
        return uppercaseDescription.indexOf(this.keyword) > -1;        
    }
}

/**
 * Filter to keep tasks that have priority. 
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

 */
class KeepTasksWithPriority implements TaskFilter {    
    @Override
    public boolean apply(Task t) {
         return t.getPriority() > 0;
    }
}

/**
 * Filter to keep events.
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

 */
class KeepTasksWithStartDate implements TaskFilter {
    @Override
    public boolean apply(Task t) {
        return t.getDate() != null; // True if there is start date.
    }
}

/**
 * Filter to keep tasks. 
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

 */
class KeepTasksWithoutStartDate implements TaskFilter {
    @Override
    public boolean apply(Task t) {
        return t.getDate() == null; // True if there is no start date.
    }
}

/**
 * Filter to keep reminders (tasks without start and end time).
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

 */
class KeepReminders implements TaskFilter {
    @Override
    public boolean apply(Task t) {
        return t.getDate() == null && t.getEndDate() == null;
    }
}

/**
 * Filter to ignore (soft-)deleted tasks. 
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

 */
class IgnoreTasksDeleted implements TaskFilter { // Keep tasks which are not deleted.
    @Override
    public boolean apply(Task t) {
        return !t.isDeleted(); // True if not deleted. 
    }
}

/**
 * Filter to keep uncompleted tasks. 
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

 */
class KeepTasksNotCompleted implements TaskFilter {
    @Override
    public boolean apply(Task t) {
        return !t.isCompleted();
    }
}

/**
 * The main class to store and run the filters. 
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

 */
public class TaskListFilter {
    private ArrayList<TaskFilter> filters;
    private boolean strongFilter; // true for AND/&&, false for OR/||.

    /**
     * @param strongFilter true to use &&/AND filtering, false to use ||/OR filtering. 
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

     */
    public TaskListFilter(boolean strongFilter) {
        this.filters = new ArrayList<TaskFilter>();
        this.strongFilter = strongFilter;
    }

    /**
     * @param filter adds the filter into the list. 
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

     */
    public void add(TaskFilter filter) {
        this.filters.add(filter);
    }

    /**
     * Runs the filters.
     * @param taskList the ArrayList to filter.
     * @return the filtered ArrayList of tasks.
	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

     */
    public ArrayList<Task> apply(ArrayList<Task> taskList) {
        ArrayList<Task> filteredTaskList = new ArrayList<Task>();
        ListIterator<Task> taskI = taskList.listIterator();
        ListIterator<TaskFilter> filterI;
        Task task;
        TaskFilter filter;
        boolean keep = this.strongFilter;
        
        while (taskI.hasNext()) {
            task = taskI.next();
            keep = this.strongFilter;
            filterI = this.filters.listIterator();
            while (filterI.hasNext()) {
                filter = filterI.next();
                if (this.strongFilter) { // Strong filter is on, do &&.
                    if (!filter.apply(task)) { // Once false,
                        keep = false; // Do not keep.
                        break; // Get out of the while loop.
                    }
                }
                else { // Strong filter is off, do ||.
                    if (filter.apply(task)) { // Once true,
                        filteredTaskList.add(task);
                        break; // Get out of the while loop.
                    }
                }
            }
            // Only add at this point if it is a strong filter and kept.
            if (this.strongFilter && keep) { filteredTaskList.add(task); }
        }
        
        return filteredTaskList;
    }
}




	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskManager.java
	 */

 */
public class TaskManager {
    public static final char NORMAL_TASK_PREFIX = 'T';
    public static final char DATED_TASK_PREFIX = 'E';
    public static final int DEFAULT_DAYS_TO_DISPLAY = 3;
    
    private ArrayList<Task> list;
    private Task lastModifiedTask;
    private Hashtable<String, Integer> idMapping;
    
    private ListDisplay eventsDisplay;
    private ListDisplay tasksDisplay;
    
    private int daysToDisplay = DEFAULT_DAYS_TO_DISPLAY;
    
    /**
     * Initializes and sets up the task manager.
     */
    public TaskManager() {
        this.idMapping = new Hashtable<String, Integer>();
        this.eventsDisplay = new EventListDisplay();
        this.tasksDisplay = new TaskListDisplay();
    }
    
    /**
     * Sets the number of days to display in the default view.
     * @param days number of days.
     */
    public void setDaysToDisplay(int days) {
        this.daysToDisplay = days;
    }
    
    /**
     * Sets the number of days to display in the default view.
     * @param commandInfo Use start and end time to determine the number of days.
     * @param configManager The config manager to update and save the information to.
     */
    public void setDaysToDisplay(CommandInfo commandInfo, ConfigManager configManager) {
        LocalDate today = new LocalDate();
        LocalDate startDay = new LocalDate();
        if (commandInfo.getStartDateTime() != null) {
            startDay = commandInfo.getStartDateTime().toLocalDate();
        }
        if (startDay.equals(today) && commandInfo.getEndDateTime() != null) {
            LocalDate endDay = commandInfo.getEndDateTime().toLocalDate();
            this.daysToDisplay = Days.daysBetween(startDay, endDay).getDays();
            configManager.setHomeViewType(this.daysToDisplay);
        }
    }
    
    /**
     * Checks if the task displayID entered is valid.
     * 
     * @param displayID the task displayID the user entered.
     * @return whether it exists in idMapping.
     */
    public boolean ensureValidDisplayID(String displayID) {
        return this.idMapping.containsKey(displayID);
    }
    
    /**
     * Used to map displayID to actual taskID.
     * 
     * @param displayID the display ID that is shown in the list view.
     * @return taskID the internal ID of the Task.
     */
    private int mapDisplayIDtoActualID(String displayID) {
        assert(this.idMapping.containsKey(displayID) == true);
        return this.idMapping.get(displayID);
    }
    

    /**
     * Initializes the list of tasks from storage.
     * 
     * @param storedList ArrayList of tasks.
     * @return the initialized list of tasks.
     */
    public ArrayList<Task> initializeList(ArrayList<Task> storedList) {
        list = new ArrayList<Task>(storedList);
        Task.resetIDCounter(list.size());
        return this.list;
    }
    
    /**
     * Returns the last task modified.
     * @return the last task modified.
     */    
    public Task getLastModifiedTask() {
        return this.lastModifiedTask;
    }
    
    
    /**
     * Returns a list of invalid display IDs.
     * @return a list of invalid display IDs, or null if none.
     */
    public ArrayList<String> getInvalidDisplayIDs(ArrayList<String> taskIDs) {
        if (taskIDs == null) { return null; }
        
        ArrayList<String> invalidIDs = new ArrayList<String>();

        ListIterator<String> li = taskIDs.listIterator();
        while (li.hasNext()) {
            String taskID = li.next();
            if (!this.idMapping.containsKey(taskID)) { // Invalid id...
                invalidIDs.add(taskID);
            }
        }
        
        if (invalidIDs.size() == 0) { return null; }
        return invalidIDs;
    }
    
    /**
     * Clears the ID mapping hashtable.
     */
    public void clearIDMapping() { this.idMapping.clear(); }
    
    /**
     * Returns the Task associated with this displayID.
     * @param displayID the displayID of the task.
     * @throws IllegalArgumentException if the displayID is not displayed in the views.
     */
    public Task getTaskFromDisplayID(String displayID) throws IllegalArgumentException {
        if (!this.ensureValidDisplayID(displayID)) {
            throw new IllegalArgumentException("There is no such display ID.");
        }
        return this.list.get(this.mapDisplayIDtoActualID(displayID));
    }
    
    /**
     * Adds a task to the list.
     * 
     * @param commandInfo of type "add".
     */
    public void add(CommandInfo commandInfo) {
        assert(commandInfo.getCommandType() == "add");
        this.lastModifiedTask = new Task(commandInfo);
        this.list.add(this.lastModifiedTask);
    }

    /**
     * Edits a task in the list.
     * 
     * @param commandInfo of type "edit" and contains task id.
     */
    public void edit(CommandInfo commandInfo) {  
        assert(commandInfo.getCommandType() == "edit");
        int taskId = this.mapDisplayIDtoActualID(commandInfo.getTaskIDs().get(0));       
        this.lastModifiedTask = new Task(commandInfo, taskId);
        
        this.list.set(taskId, this.lastModifiedTask); // Replaces the task.
    }

    /**
     * Deletes a task in the list.
     * 
     * @param commandInfo of type "delete" and contains task id(s).
     */
    public void delete(CommandInfo commandInfo) {
        assert(commandInfo.getCommandType() == "delete");
        ListIterator<String> li = commandInfo.getTaskIDs().listIterator();
        while (li.hasNext()) {
            String displayID = li.next();
            int taskId = this.mapDisplayIDtoActualID(displayID);
            this.list.get(taskId).setDeleted(true);
        }
    }
    
    /**
     * Completes a task in the list.
     * 
     * @param commandInfo of type "complete" and contains task id(s).
     */
    public void complete(CommandInfo commandInfo) {   
        assert(commandInfo.getCommandType() == "complete");
        ListIterator<String> li = commandInfo.getTaskIDs().listIterator();
        while (li.hasNext()) {
            String displayID = li.next();
            int taskId = this.mapDisplayIDtoActualID(displayID);
            this.list.get(taskId).complete(); // "Soft-delete" in the ArrayList.
        }
    }

    /**
     * Undos one previous commandInfo.
     * 
     * @param commandInfo of type "undo".
     * @param backup the backup task list.
     */
    public void undo(CommandInfo commandInfo, ArrayList<Task> backup) {
        assert(commandInfo.getCommandType() == "undo");
        this.list = new ArrayList<Task>(backup);
    }
    
    /**
     * Returns the full list of tasks, including the deleted tasks.
     * @return the full list of tasks, including the deleted tasks.
     */
    public ArrayList<Task> getFullList() {
        return this.list;
    }

    /**
     * Returns the full list of tasks, ignoring the deleted tasks.
     * 
     * @return the full list of tasks, ignoring the deleted tasks.
     */
    public ArrayList<Task> getSanitizedList() {
        TaskListFilter filter = new TaskListFilter(true); // Does a AND/&& filtering.
        filter.add(new IgnoreTasksDeleted());
        return filter.apply(this.list);
    }
    
    /**
     * Returns the tasks without start dates.
     * 
     * @return the tasks without start dates.
     */
    public ArrayList<Task> getTasks() {
        TaskListFilter filter = new TaskListFilter(false); // Does a OR/|| filtering.
        filter.add(new KeepTasksCompletedToday()); // or,
        filter.add(new KeepTasksOutstanding());
        filter.add(new KeepReminders());
        filter.add(new KeepTasksBetween(this.daysToDisplay));
        this.tasksDisplay.replaceFilter(filter);
        
        return this.tasksDisplay.display(this.list, this.idMapping);
    }
    
    /**
     * Returns the tasks with start dates.
     * 
     * @return the tasks with start dates.
     */
    public ArrayList<Task> getEvents() {
        TaskListFilter filter = new TaskListFilter(false); // Does a OR/|| filtering.
        filter.add(new KeepTasksCompletedToday()); // or,
        filter.add(new KeepTasksOutstanding());
        filter.add(new KeepTasksBetween(this.daysToDisplay));
        this.eventsDisplay.replaceFilter(filter);
        
        return this.eventsDisplay.display(this.list, this.idMapping);
    }
    
    /**
     * Returns the tasks given in the search parameters.
     * 
     * @return the tasks given in the search parameters.
     */
    public ArrayList<Task> getSearchedTasks(CommandInfo commandInfo) {        
        ArrayList<Comparator<Task>> comparators = new ArrayList<Comparator<Task>>();        
        TaskListFilter filter = new TaskListFilter(true); // AND filter.
        
        // Filtering of dates:
        DateTime start = commandInfo.getStartDateTime();
        DateTime end = commandInfo.getEndDateTime();
        if (start != null && end != null) {
            filter.add(new KeepTasksBetween(start, end));
            comparators.add(new EndDateComparator());
        }
        else if (start != null) { // end is null, not possible here but whatever,
            end = start.withTimeAtStartOfDay().plusDays(1);
            start = start.withTimeAtStartOfDay().minusMillis(1); // Millisecond before today.
            filter.add(new KeepTasksBetween(start, end));
            comparators.add(new EndDateComparator());
        }
        else if (end != null) { // start is null,
            start = new DateTime();
            filter.add(new KeepTasksBetween(start, end));
            comparators.add(new EndDateComparator());
        }

        // Whether to show priority:
        if (commandInfo.getPriority() > 0) {
            filter.add(new KeepTasksWithPriority());
        }
        
        // Whether to show completed only:
        if (commandInfo.isCompleted()) { // For completed tasks only.
            filter.add(new KeepTasksCompleted());
            comparators.add(new CompletedAtComparator());
        }
        
        // Searching by keywords:
        if (commandInfo.getTaskDesc() != null) {
            filter.add(new KeepTasksWithKeyword(commandInfo.getTaskDesc()));
        }
        
        this.tasksDisplay.replaceFilter(filter);
        this.tasksDisplay.replaceComparators(comparators);
        
        return this.tasksDisplay.display(this.list, this.idMapping);
    }
    
    /**
     * Returns the events given in the search parameters.
     * 
     * @return the events given in the search parameters.
     */
    public ArrayList<Task> getSearchedEvents(CommandInfo commandInfo) {
        ArrayList<Comparator<Task>> comparators = new ArrayList<Comparator<Task>>();
        TaskListFilter filter = new TaskListFilter(true); // AND filter.

        // Whether to show completed only:
        if (commandInfo.isCompleted()) { // For completed tasks only.
            filter.add(new KeepTasksCompleted());
            comparators.add(new CompletedAtComparator());
        }
        
        // Whether to show priority, inclusive:
        if (commandInfo.getPriority() > 0) {
            filter.add(new KeepTasksWithPriority());
        }
        
        // Filtering of dates:
        DateTime start = commandInfo.getStartDateTime();
        DateTime end = commandInfo.getEndDateTime();
        if (start != null && end != null) {
            filter.add(new KeepTasksBetween(start, end));
            comparators.add(new DateComparator());
        }
        else if (start != null) { // end is null,
            end = start.withTimeAtStartOfDay().plusDays(1);
            start = start.withTimeAtStartOfDay().minusMillis(1); // Millisecond before today.
            filter.add(new KeepTasksBetween(start, end));
            comparators.add(new DateComparator());
        }
        else if (end != null) { // start is null, not possible here but whatever,
            start = new DateTime();
            filter.add(new KeepTasksBetween(start, end));
            comparators.add(new DateComparator());
        }
        
        // Searching by keywords:
        if (commandInfo.getTaskDesc() != null) {
            filter.add(new KeepTasksWithKeyword(commandInfo.getTaskDesc()));
        }
        
        this.eventsDisplay.replaceFilter(filter);
        this.eventsDisplay.replaceComparators(comparators);
        
        return this.eventsDisplay.display(this.list, this.idMapping);
    }
    
}

	// End of segment: .\src\task\TaskManager.java





	/**
	 * origin: .\test\application\IntegrationTest.java
	 */

 *
 */
class ControllerReflector {
    // Hashtable to map each method and field to their own name.
    public static Hashtable<String, Method> methods = new Hashtable<String, Method>();
    public static Hashtable<String, Field> fields = new Hashtable<String, Field>();

    public static void reflect() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        Class<?> controller = Controller.class;
  
        // Reflects the private static methods.
        Method m[] = controller.getDeclaredMethods();
        for (Method method : m) {
            methods.put(method.getName(), method);
            method.setAccessible(true);
        }
  
        // Reflects the private static fields.
        Field f[] = controller.getDeclaredFields();
        for (Field field : f) {
            fields.put(field.getName(), field);
            field.setAccessible(true);
        }
    }
}

	// End of segment: .\test\application\IntegrationTest.java





	/**
	 * origin: .\test\application\IntegrationTest.java
	 */

 *
 */
public class IntegrationTest extends Application {
    private static final String TODO_TEST_JSON_FILENAME = "Todo.test.json"; // To be used in tests.
    private static final String SAMPLE_TEST_JSON_FILENAME = "SampleTodo.test.json"; // To be loaded in tests.
    private static final Object[] EMPTY = {};
    static UIComponent uiComponent;
    static TaskManager taskManager = new TaskManager();
    static DataStorage dataStorage = new DataStorage(TODO_TEST_JSON_FILENAME);
    static int FIXTURES_SIZE;
    static int TASKS_SIZE;
    static int EVENTS_SIZE;
	static UIAutoComplete autocomplete;
	static UICmdInputBox inputBox;
	static UIAutoCompleteListener acListener;
	
	// End of segment: .\test\application\IntegrationTest.java





	/**
	 * origin: .\test\task\TaskTest.java
	 */

 *
 */
public class TaskTest {
    private Task task;

    @Before
    public void setUp() {
        task = new Task();
    }

    @After
    public void tearDown() {
    }

    /**
     * Test method for {@link task.Task#getID()}.
     */
    @Test
    public void testGetId() {
        assertNotNull(task.getID());
    }
    
    /**
     * Test method for {@link task.Task#displayID()}.
     */
    @Test
    public void testDisplayId() {
        assertNull("has null displayID", task.getDisplayID());
        
        String displayID = "F1";
        task.setDisplayID(displayID);
        assertEquals("has set displayID", displayID, task.getDisplayID());
    }

    /**
     * Test method for {@link task.Task#description}.
     */
    @Test
    public void testDescription() {
        assertNull("has null description", task.getDescription());
        
        String description = "description";
        task.setDescription(description);
        assertEquals("has set description", description, task.getDescription());
    }

    /**
     * Test method for {@link task.Task#date}.
     */
    @Test
    public void testDate() {
        assertNull("has null date", task.getDate());
        
        DateTime date = new DateTime(2014, 10, 11, 12, 44, 0);
        task.setDate(date);
        assertEquals("has set date", date, task.getDate());
        
        task.setDate(null);
        assertNull("has set null date", task.getDate());
    }

    /**
     * Test method for {@link task.Task#endDate}.
     */
    @Test
    public void testEndDate() {
        assertNull("has null endDate", task.getEndDate());
        
        DateTime endDate = new DateTime(2014, 10, 11, 12, 44, 0);
        task.setEndDate(endDate);
        assertEquals("has set endDate", endDate, task.getEndDate());
        
        task.setEndDate(null);
        assertNull("has set null endDate", task.getEndDate());
    }

    /**
     * Test method for {@link task.Task#completed}.
     */
    @Test
    public void testCompleted() {
        assertFalse("is not completed", task.isCompleted());
        
        task.complete();
        assertTrue("is completed", task.isCompleted());
        
        task.setCompleted(false);
        assertFalse("is not completed again", task.isCompleted());
    }

    /**
     * Test method for {@link task.Task#priority}.
     */
    @Test
    public void testPriority() {
        assertEquals("has no priority", task.getPriority(), 0);
        
        int priority = 1;
        task.setPriority(priority);
        assertEquals("has priority", priority, task.getPriority());        
    }

}

	// End of segment: .\test\task\TaskTest.java





