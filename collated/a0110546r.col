//@author: a0110546r



	/**
	 * origin: .\src\application\Controller.java
	 */

    /**
     * Executes the command entered.
     * 
     * @param input The entire command input.
     */
    public static void runCommandInput(String input) {
        logger.log(Level.FINE, "runCommandInput(input: {0} )", input);

        CommandInfo commandInfo = null;
        
        // Ensures valid command input.
        try {
            commandInfo = (new Parser()).getCommandInfo(input);
        } catch (InvalidCommandException e) {
            uiComponent.setSuggestionText(e.getMessage());
            return;
        }
        assert(commandInfo != null);
        
        Message feedback = null;
        
        // Check for invalid IDs.
        ArrayList<String> invalidIDs = taskManager.getInvalidDisplayIDs(commandInfo.getTaskIDs());
        if (invalidIDs != null) {
            feedback = new MessageWarningInvalidID(invalidIDs);
            uiComponent.setSuggestionText(feedback.getMessage());
            logger.log(feedback.getMessage());
            return;
        }

        // Run the command.         
        switch (commandInfo.getCommandType()) {
            case InputCommands.ADD:
                taskManager.add(commandInfo);
                break;
            case InputCommands.DELETE:
                taskManager.delete(commandInfo);
                feedback = new MessageNotifyDelete(commandInfo.getTaskIDs());
                break;
            case InputCommands.EDIT:
                taskManager.edit(commandInfo);
                feedback = new MessageNotifyEdit(commandInfo.getTaskIDs().get(0));
                break;
            case InputCommands.UNDO:
                taskManager.undo(commandInfo, backup.getPastVersion());
                feedback = new MessageNotifyUndo();
                break;
            case InputCommands.COMPLETE:
                taskManager.complete(commandInfo);
                feedback = new MessageNotifyComplete(commandInfo.getTaskIDs());
                break;
            case InputCommands.HOME:
                break;
            case InputCommands.SHOW:
                taskManager.setDaysToDisplay(commandInfo, configManager);
                // continues:
            case InputCommands.SEARCH:
                taskManager.clearIDMapping();
                uiComponent.updateRightPanel(taskManager.getSearchedTasks(commandInfo), NAME_TODOS + " " + NAME_SEARCH_RESULTS);
                uiComponent.updateLeftPanel(taskManager.getSearchedEvents(commandInfo), NAME_EVENTS + " " + NAME_SEARCH_RESULTS);
                return;
            case InputCommands.QUIT:
            case InputCommands.EXIT:
                Platform.exit();
                return;
            	
        }
        
        taskManager.clearIDMapping();
        uiComponent.updateRightPanel(taskManager.getTasks(), NAME_TODOS);
        uiComponent.updateLeftPanel(taskManager.getEvents(), NAME_EVENTS);
        
        backup.storeBackup(taskManager.getFullList());
        dataStorage.saveTasks(taskManager.getSanitizedList());
        
        // Can only get display id after displaying.
        if ("add".equals(commandInfo.getCommandType())) {
            feedback = new MessageNotifyAdd(taskManager.getLastModifiedTask().getDisplayID());
        }
        
        if (feedback != null) {
            uiComponent.setSuggestionText(feedback.getMessage());
            logger.log(feedback.getMessage());
        }
    }
    

	// End of segment: .\src\application\Controller.java





	/**
	 * origin: .\src\application\Controller.java
	 */

    /**
     * For the UI to retrieve the list of tasks after it is initialized.
     */
    public static void getTasks() {
        uiComponent.updateRightPanel(taskManager.getTasks(), NAME_TODOS);
        uiComponent.updateLeftPanel(taskManager.getEvents(), NAME_EVENTS);
    }
    
	// End of segment: .\src\application\Controller.java





	/**
	 * origin: .\src\application\Controller.java
	 */

    /**
     * For the UI to retrieve the Task given the display ID.
     * @param displayID the displayID of the task.
     */
    public static Task getTaskFromDisplayID(String displayID) {
        try {
            return taskManager.getTaskFromDisplayID(displayID.toUpperCase());
        } catch (IllegalArgumentException e) {
            uiComponent.setSuggestionText(e.getMessage());
            // There is no need to log this.
        }
        return null;
    }
    
	// End of segment: .\src\application\Controller.java





	/**
	 * origin: .\src\application\Controller.java
	 */

    private static void setup() {
        dataStorage = new DataStorage();
        dataStorage.initiateFile();
        
        taskManager = new TaskManager();
        taskManager.initializeList(dataStorage.retrieveTasks());
        
        configManager = new ConfigManager();
        taskManager.setDaysToDisplay(configManager.getHomeViewType());
        
        backup = new Backup();
        backup.storeBackup(taskManager.getFullList());
        
        new DateTimeParser("start now"); // To reduce lag on adding the first event.
    }
    
	// End of segment: .\src\application\Controller.java





	/**
	 * origin: .\src\application\Controller.java
	 */

    public static void main(String[] args) {
        setup();
        launch(args);
    }

	// End of segment: .\src\application\Controller.java





	/**
	 * origin: .\src\application\Controller.java
	 */

    @Override
    public void start(Stage primaryStage) throws Exception {
        uiComponent = new UIComponent();
        primaryStage.getIcons().add(new Image("/UI/wavewave.png"));
        uiComponent.showStage(primaryStage);
    }
}

	// End of segment: .\src\application\Controller.java





	/**
	 * origin: .\src\application\InvalidCommandException.java
	 */

public class InvalidCommandException extends Exception {
    private static final long serialVersionUID = 2673862145114002300L; // Eclipse wants to have this.

    public InvalidCommandException() {}
    
    public InvalidCommandException(String message) {
        super(message);
    }
}


	// End of segment: .\src\application\InvalidCommandException.java





	/**
	 * origin: .\src\application\WaveLogger.java
	 */

/**
 * Our custom logging class that wraps Logger.
 * Control loggers that output to the console by adding their
 * names into consoleOutput.txt.
 * 
 *
 */
public class WaveLogger {
    private static final String consoleOutputList = "consoleOutput.txt";
    
    private final Logger logger;
    private FileHandler fileHandler;
    
    /**
     * Constructs a new logger.
     * Preferably use literal strings for the name of the logger.
     * e.g. "Controller" instead of Controller.class.getName()
     * 
     * @param name the name of the file, without extension.
     */
    public WaveLogger(String name) {
        this.logger = Logger.getLogger(name);
        
        try { // Creates the log directory if it does not exist.
            new File("log").mkdirs();
        } catch (Exception e) {
            logger.log(Level.SEVERE, null, e);
        }
        
        try {
            this.fileHandler = new FileHandler("log\\" + name + ".log");
            this.fileHandler.setFormatter(new SimpleFormatter());
            this.logger.addHandler(this.fileHandler);
        } catch (Exception e) {
            // This will log to the console.
            logger.log(Level.SEVERE, null, e);
        }
        
        this.logger.setLevel(Level.FINEST);
        
        // If not in console output list...
        if (!useConsoleOutput(name)) {
            // Prevents console output.
            this.logger.setUseParentHandlers(false);
        }
    }
    
    private static boolean useConsoleOutput(String name) {
        try {
            Scanner sc = new Scanner(new FileReader(consoleOutputList));
            while (sc.hasNext()) {
                String nameInList = sc.nextLine();
                
                if (name.equals(nameInList)) {
                    sc.close();
                    return true;
                }
            }
            sc.close();
            return false;  
        }
        catch (FileNotFoundException e) {
            return false;
        }      
    }
        
    /**
     * Wraps Logger log method with fine grained level control
     * and message parameters.
     * 
     * @param level the intensity of the message.
     * @param message the message.
     * @param param any objects to pass into message.
     */
    public void log(Level level, String message, Object param) {
        this.logger.log(level, message, param);
    }
    
    /**
     * Wraps Logger log method with fine grained level control.
     * 
     * @param level the intensity of the message.
     * @param message the message.
     */
    public void log(Level level, String message) {
        this.logger.log(level, message);
    }
    
    /**
     * Basic logging log without having to care about levels.
     * 
     * @param message simply the message.
     */
    public void log(String message) {
        this.logger.log(Level.INFO, message);
    }
}

	// End of segment: .\src\application\WaveLogger.java





	/**
	 * origin: .\src\task\ListDisplay.java
	 */

/**
 * The list display class.
 *
 */
public class ListDisplay {
    protected char TASK_PREFIX = ' ';
    
    protected ArrayList<Comparator<Task>> defaultComparators;
    protected TaskListFilter defaultFilter;
    
    protected ArrayList<Comparator<Task>> additionalComparators;
    protected TaskListFilter additionalFilter;
    
    public ListDisplay() {
        this.defaultComparators = new ArrayList<Comparator<Task>>();
        this.defaultFilter = new TaskListFilter(true); // Does a AND/&& filtering.
        this.additionalComparators = new ArrayList<Comparator<Task>>();
        this.additionalFilter = new TaskListFilter(false);
    }
    
    /**
     * Adds a non-default comparator.
     * @param comparator Comparator<Task>
     */
    public void addComparator(Comparator<Task> comparator) {
        this.additionalComparators.add(comparator);
    }
    
    /**
     * Adds a non-default filter.
     * @param filter TaskFilter
     */
    public void addFilter(TaskFilter filter) {
        this.additionalFilter.add(filter);
    }
    
    /**
     * Replaces the entire task list filter.
     * @param filter TaskListFilter
     */
    public void replaceFilter(TaskListFilter filter) {
        this.additionalFilter = filter;
    }
    
    /**
     * Replaces the entire comparators list.
     * @param comparators ArrayList of Comparator<Task>
     */
    public void replaceComparators(ArrayList<Comparator<Task>> comparators) { 
        this.additionalComparators = comparators;
    }
    
    private static void runComparators(ArrayList<Comparator<Task>> comparators, ArrayList<Task> taskList) {
        ListIterator<Comparator<Task>> li = comparators.listIterator();
        while (li.hasNext()) {
            Collections.sort(taskList, li.next());
        }
    }
    
    /**
     * First filters and sorts using the default filters and comparators, if any.
     * Then filters and sorts using the additional filters and comparators, if any.
     * 
     * @param taskList the list to filter and sort.
     * @param idMapping the Hashtable that maps displayID to internal ID.
     * @return a filtered and sorted ArrayList<Task> 
     */
    public ArrayList<Task> display(ArrayList<Task> taskList, Hashtable<String, Integer> idMapping) {
        ArrayList<Task> filteredTasks = this.defaultFilter.apply(taskList);
        runComparators(this.defaultComparators, filteredTasks);
        
        filteredTasks = this.additionalFilter.apply(filteredTasks);
        runComparators(this.additionalComparators, filteredTasks);

        int i = 1;
        ListIterator<Task> li = filteredTasks.listIterator();
        while (li.hasNext()) {
            Task t = li.next();
            String displayID = this.TASK_PREFIX + "" + i;
            idMapping.put(displayID, t.getID());
            t.setDisplayID(displayID);
            i++;
        }
        
        return filteredTasks;
    }
    
}

/**
 * Events display filters to keep tasks with start dates.
 * Sorts primarily by day, then priority and completion status.
 */
class EventListDisplay extends ListDisplay {    
    public EventListDisplay() {
        super();
        this.TASK_PREFIX = TaskManager.DATED_TASK_PREFIX;
        
        this.defaultFilter.add(new IgnoreTasksDeleted()); // and,
        this.defaultFilter.add(new KeepTasksWithStartDate());
        
        this.defaultComparators.add(new CompletedAtComparator());
        this.defaultComparators.add(new DayPriorityComparator());
    }
}

/**
 * Tasks display filters to keep tasks without start dates.
 * Sorts primarily by completion status, then end dates, then priority and last modified.
 */
class TaskListDisplay extends ListDisplay {    
    public TaskListDisplay() {
        super();
        this.TASK_PREFIX = TaskManager.NORMAL_TASK_PREFIX;
        
        this.defaultFilter.add(new IgnoreTasksDeleted()); // and,
        this.defaultFilter.add(new KeepTasksWithoutStartDate());
        
        this.defaultComparators.add(new ModifiedAtComparator());
        this.defaultComparators.add(new PriorityComparator());
        this.defaultComparators.add(new EndDateComparator());
        this.defaultComparators.add(new CompletedAtComparator());
    }
}
	// End of segment: .\src\task\ListDisplay.java





	/**
	 * origin: .\src\task\Task.java
	 */

/**
 * The task object!
 * 
 */
public class Task {    
    private static int idCounter = 0;
    
    /* The following fields are not stored. */
    private int id;
    private String displayID;
    private boolean deleted = false;
    
    /* The following attributes are stored. */
    private String description;
    private DateTime date;
    private DateTime endDate;
    private boolean completed;
    private int priority;    
    private DateTime createdAt;
    private DateTime modifiedAt;
    private DateTime completedAt;

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Constructor that creates a Task based on CommandInfo.
     * 
     * @param commandInfo the CommandInfo object that contains parsed information.
     */
    public Task(CommandInfo commandInfo) {
        this(); // Calls default constructor first.
        
        this.description = commandInfo.getTaskDesc();
        if (commandInfo.getStartDateTime() != null) {
            this.date = commandInfo.getStartDateTime();
        }
        if (commandInfo.getEndDateTime() != null) {
            this.endDate = commandInfo.getEndDateTime();
        }
        if (commandInfo.getPriority() != 0) {
            this.priority = commandInfo.getPriority();
        }
    }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Constructor that edits an existing Task based on CommandInfo and assigns the same id.
     * 
     * @param commandInfo the CommandInfo object that contains parsed information.
     * @param id an existing Task id.
     */
    public Task(CommandInfo commandInfo, int id) {
        this(commandInfo); // Calls commandInfo constructor first.
        this.id = id;
        Task.idCounter--; // Because we are editing, so do not increment the counter.
    }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Public default constructor.
     */
    public Task() {
        this.id = Task.idCounter++;
        this.createdAt = new DateTime();
        this.modifiedAt = new DateTime();
    }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Returns the id of the Task.
     * 
     * @return the id of the Task.
     */
    public int getID() { return this.id; }


	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Returns the description of the Task.
     * 
     * @return the description of the Task.
     */
    public String getDescription() { return this.description; }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Sets the description of the Task.
     * 
     * @param description overwrites the description of the Task.
     */
    public void setDescription(String description) {
        this.description = description;
        this.modifiedAt = new DateTime();
    }    

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Returns the displayID of the Task.
     * 
     * @return the displayID of the Task.
     */
    public String getDisplayID() { return this.displayID; }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Sets the displayID of the Task.
     * 
     * @param description overwrites the displayID of the Task.
     */
    public void setDisplayID(String displayID) {
        this.displayID = displayID;
        // this.modifiedAt = new DateTime(); // This does not modify the task. 
    }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Returns the (start) date of the Task. Returns null if there is no date.
     * 
     * @return the (start) date of the Task. Returns null if there is no date.
     */
    public DateTime getDate() { return this.date; }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Sets the (start) date of the Task. Set as null to remove the date.
     * 
     * @param date sets the (start) date of the Task.
     *     Set to null to remove the date.
     */
    public void setDate(DateTime date) {
        // We should probably set endDate to null if date is null.
        this.date = date;
        this.modifiedAt = new DateTime();
    }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Returns the end date of the Task. Returns null if there is no end date.
     * 
     * @return the end date of the Task. Returns null if there is no end date.
     */
    public DateTime getEndDate() { return this.endDate; }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Sets the end date of the Task. Set as null to remove the date.
     * 
     * @param endDate sets the end date of the Task. Set to null to remove the date.
     */
    public void setEndDate(DateTime endDate) {
        this.endDate = endDate;
        this.modifiedAt = new DateTime();
    }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Returns whether Task is completed.
     * 
     * @return boolean whether Task is completed.
     */
    public boolean isCompleted() { return completed; }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Sets the completed status of the Task.
     * 
     * @param completed overwrites the completed status of the Task.
     */
    public void setCompleted(boolean completed) {
        this.completed = completed;
        this.modifiedAt = new DateTime();
        if (completed) {
            this.completedAt = new DateTime(this.modifiedAt);
        }
        else {
            this.completedAt = null;
        }
    }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Completes the task.
     */
    public void complete() { this.setCompleted(true); }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Returns the priority of the Task.
     * 
     * @return int priority of the Task.
     */
    public int getPriority() { return this.priority; }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Sets the priority of the Task.
     * 
     * @param priority overwrites the priority of the Task.
     */
    public void setPriority(int priority) {
        // Check if priority is negative.
        if (priority > 0) { priority = 1; }
        else { priority = 0; }
        this.priority = priority;
        this.modifiedAt = new DateTime();
    }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Returns the created date of the Task.
     * 
     * @return the created date of the Task.
     */
    public DateTime getCreatedAt() { return this.createdAt; }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Sets the created date of the Task.
     * Used only when retrieving tasks list from external file.
     * 
     * @param createdDate the created DateTime of the Task.
     */
    public void setCreatedAt(DateTime createdDate) {
        this.createdAt = createdDate;
    }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Returns the last modified date of the Task.
     * 
     * @return the last modified date of the Task.
     */
    public DateTime getModifiedAt() { return this.modifiedAt; }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Sets the last modified date of the Task. 
     * Used only when retrieving tasks list from external file.
     * 
     * @param modifiedDate the last modified DateTime of the Task.
     */
    public void setModifiedAt(DateTime modifiedDate) {
        this.modifiedAt = modifiedDate;
    }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Returns the completed date of the Task.
     * 
     * @return the completed date of the Task.
     */
    public DateTime getCompletedAt() { return this.completedAt; }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Sets the completed date of the Task.
     * Used only when retrieving tasks list from external file.
     * 
     * @param completedDate the completed DateTime of the Task.
     */
    public void setCompletedAt(DateTime completedDate) {
        this.completedAt = completedDate;
    }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Returns whether this task is deleted.
     * 
     * @return whether this task is deleted.
     */
    public boolean isDeleted() { return this.deleted; }

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Sets whether the Task is deleted.
     * @param deleted boolean whether to delete the Task.
     */
    public void setDeleted(boolean deleted) { this.deleted = deleted; }   
    

	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Used to reset the internal ID counter back to 0.
     */
    public static void resetIDCounter() { resetIDCounter(0); }
    
	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\Task.java
	 */

    /**
     * Used to set the internal ID counter.
     * @param count the number to set to.
     */
    public static void resetIDCounter(int count) {
        assert(count >= 0);
        idCounter = count;
    }
}


	// End of segment: .\src\task\Task.java





	/**
	 * origin: .\src\task\TaskComparators.java
	 */

/**
 * The comparator class used to sort Tasks by their date.
 * 
 */
class DateComparator implements Comparator<Task> {
    @Override
    public int compare(Task a, Task b) {
        if (a.getDate().isAfter(b.getDate())) {
            return 1; // a is after b, so a comes after b.
        } else if (a.getDate().isBefore(b.getDate())) {
            return -1; // a is before b, so a comes before b.
        } else {
            if (a.getEndDate() == null && b.getEndDate() == null) { // Untested.
                return 0; // both a and b has no end date, do nothing.
            } else if (a.getEndDate() == null) { // Untested.
                return 1; // a has no end date, b has end date, so a comes after b. 
            } else if (a.getEndDate().isAfter(b.getEndDate())) {
                return 1; // a is after b, so a comes after b.
            } else if (a.getEndDate().isBefore(b.getEndDate())) {
                return -1; // a is before b, so a comes before b.
            }
        }
        return 0;
    }
}

	// End of segment: .\src\task\TaskComparators.java





	/**
	 * origin: .\src\task\TaskComparators.java
	 */

/**
 * The comparator class used to sort Tasks by their end date.
 *
 */
class EndDateComparator implements Comparator<Task> {
    @Override
    public int compare(Task a, Task b) {
        if (a.getEndDate() == null && b.getEndDate() == null) {
            return 0;
        } else if (a.getEndDate() == null) {
            return 1; // b has end date, so a comes after b.
        } else if (b.getEndDate() == null) {
            return -1; // a has end date, so a comes before b.
        } else { // Both a and b has end date,
            if (a.getEndDate().isAfter(b.getEndDate())) {
                return 1; // a is after b, a comes after b.
            } else if (a.getEndDate().isBefore(b.getEndDate())) {
                return -1; // a is before b, so a comes before b.
            }
        }
        return 0;
    }
}

	// End of segment: .\src\task\TaskComparators.java





	/**
	 * origin: .\src\task\TaskComparators.java
	 */

/**
 * The comparator class used to sort Tasks by their completed at date.
 * 
 */
class CompletedAtComparator implements Comparator<Task> {
    @Override
    public int compare(Task a, Task b) {
        if (a.getCompletedAt() == null && b.getCompletedAt() == null) {
            return 0;
        } else if (a.getCompletedAt() == null) {
            return -1; // b has completed date, so a comes before b.
        } else if (b.getCompletedAt() == null) {
            return 1; // a has completed date, so a comes after b.
        } else { // Both a and b has end date,
            if (a.getCompletedAt().isAfter(b.getCompletedAt())) {
                return 1; // a is after b, a comes after b.
            } else if (a.getCompletedAt().isBefore(b.getCompletedAt())) {
                return -1; // a is before b, so a comes before b.
            }
        }
        return 0;
    }
}

	// End of segment: .\src\task\TaskComparators.java





	/**
	 * origin: .\src\task\TaskComparators.java
	 */

/**
 * The comparator class used to sort Tasks by their created at date.
 * 
 */
class ModifiedAtComparator implements Comparator<Task> {
    @Override
    public int compare(Task a, Task b) {
        if (a.getModifiedAt().isAfter(b.getModifiedAt())) {
            return -1; // a is after b, so a comes after b.
        } else if (a.getModifiedAt().isBefore(b.getModifiedAt())) {
            return 1; // a is before b, so a comes before b.
        }
        return 0;
    }
}

	// End of segment: .\src\task\TaskComparators.java





	/**
	 * origin: .\src\task\TaskComparators.java
	 */

/**
 * The comparator class used to sort Tasks by their priority.
 * 
 */
class PriorityComparator implements Comparator<Task> {
    @Override
    public int compare(Task a, Task b) {
        // a is greater priority, a should be before b.
        return b.getPriority() - a.getPriority();
    }
}

	// End of segment: .\src\task\TaskComparators.java





	/**
	 * origin: .\src\task\TaskComparators.java
	 */

/**
 * The comparator class used to sort Tasks by days and within each day, by priority.
 * 
 */
class DayPriorityComparator implements Comparator<Task> {
    @Override
    public int compare(Task a, Task b) {
        LocalDate ldtA = a.getDate().toLocalDate();
        LocalDate ldtB = b.getDate().toLocalDate();
        
        if (ldtA.isAfter(ldtB)) {
            return 1; // a is after b, so a comes after b.
        } else if (ldtA.isBefore(ldtB)) {
            return -1; // a is before b, so a comes before b.
        }

        else { // Same day, so sort by priority:
            
            if (a.getPriority() > b.getPriority()) {
                return -1; // a has greater priority, so a comes before b.
            } else if (a.getPriority() < b.getPriority()) {
                return 1; // a has smaller priority, so a comes after b.
            }
            
            // Else, priority is equal, so sort by end date:
            else if (a.getEndDate() == null && b.getEndDate() == null) {
                return 0; // both a and b has no end date, do nothing.
            } else if (a.getEndDate() == null) { // Untested.
                return 1; // a has no end date, b has end date, so a comes after b. 
            } else if (a.getEndDate().isAfter(b.getEndDate())) {
                return 1; // a is after b, so a comes after b.
            } else if (a.getEndDate().isBefore(b.getEndDate())) {
                return -1; // a is before b, so a comes before b.
            }
        }
        return 0;        
    }
}

	// End of segment: .\src\task\TaskComparators.java





	/**
	 * origin: .\src\task\TaskListFilter.java
	 */

interface TaskFilter {
    public boolean apply(Task t);
}

/**
 * Filter to keep completed tasks in the list. 
 
 */
class KeepTasksCompleted implements TaskFilter {
    @Override
    public boolean apply(Task t) {
        return t.isCompleted();
    }
}

/**
 * Filter to keep tasks which are completed in the past 24 hours. 
 
 */
class KeepTasksCompletedToday implements TaskFilter {
    private DateTime oneDayAgo;
    public KeepTasksCompletedToday() {
        this.oneDayAgo = new DateTime().minusDays(1);
    }
    
    @Override
    public boolean apply(Task t) {
        return t.getCompletedAt() != null && t.getCompletedAt().isAfter(this.oneDayAgo);
    }
}

/**
 * Filter to keep tasks which are over due. 
 
 */
class KeepTasksOutstanding implements TaskFilter {
    private DateTime now;
    public KeepTasksOutstanding() {
        this.now = new DateTime();
    }
    
    @Override
    public boolean apply(Task t) {
        if (!t.isCompleted()) {
            if (t.getEndDate() != null && t.getEndDate().isBefore(this.now)) {
                return true;
            }
            // There is no end date but only start date, and it is before now.
            else if (t.getEndDate() == null &&
                    t.getDate() != null && t.getDate().isBefore(this.now)) {
                return true;
            }
        }
        return false;
    }
}

/**
 * Filter to keep tasks between a start and end time. 
 
 */
class KeepTasksBetween implements TaskFilter {
    private DateTime start, end;
    /**
     * This constructor uses two specific date times.
     * @param start start Datetime
     * @param end end DateTime
     
     */
    public KeepTasksBetween(DateTime start, DateTime end) {
        this.start = start;
        this.end = end;
    }
    /**
     * This constructor accepts a number to use the current time and number of days later.
     * @param numDays the number of days from the current time to number of days later.
     
     */
    public KeepTasksBetween(int numDays) {
        this.start = new DateTime();
        this.end = new DateTime().plusDays(numDays);
    }
    
    @Override
    public boolean apply(Task t) {
        // There is start date,
        if (t.getDate() != null) {
            // Start date is between requested start and end,
            if (t.getDate().isAfter(this.start) && t.getDate().isBefore(this.end)) {
                return true;
            }
        }
        
        // There is end date,
        if (t.getEndDate() != null) {
            // End date is between requested start and end,
            if (t.getEndDate().isAfter(this.start) && t.getEndDate().isBefore(this.end)) {
                return true;
            }
        }
        
        return false;
    }   
}

/**
 * Filter to keep tasks that contain the keyword. 
 
 */
class KeepTasksWithKeyword implements TaskFilter {
    private String keyword;

    /**
     * @param keyword the String keyword. 
     
     */
    public KeepTasksWithKeyword(String keyword) {
        this.keyword = keyword.toUpperCase();
    }
    
    @Override
    public boolean apply(Task t) {
        String uppercaseDescription = t.getDescription().toUpperCase();
        return uppercaseDescription.indexOf(this.keyword) > -1;        
    }
}

/**
 * Filter to keep tasks that have priority. 
 
 */
class KeepTasksWithPriority implements TaskFilter {    
    @Override
    public boolean apply(Task t) {
         return t.getPriority() > 0;
    }
}

/**
 * Filter to keep events.
 
 */
class KeepTasksWithStartDate implements TaskFilter {
    @Override
    public boolean apply(Task t) {
        return t.getDate() != null; // True if there is start date.
    }
}

/**
 * Filter to keep tasks. 
 
 */
class KeepTasksWithoutStartDate implements TaskFilter {
    @Override
    public boolean apply(Task t) {
        return t.getDate() == null; // True if there is no start date.
    }
}

/**
 * Filter to keep reminders (tasks without start and end time).
 
 */
class KeepReminders implements TaskFilter {
    @Override
    public boolean apply(Task t) {
        return t.getDate() == null && t.getEndDate() == null;
    }
}

/**
 * Filter to ignore (soft-)deleted tasks. 
 
 */
class IgnoreTasksDeleted implements TaskFilter { // Keep tasks which are not deleted.
    @Override
    public boolean apply(Task t) {
        return !t.isDeleted(); // True if not deleted. 
    }
}

/**
 * Filter to keep uncompleted tasks. 
 
 */
class KeepTasksNotCompleted implements TaskFilter {
    @Override
    public boolean apply(Task t) {
        return !t.isCompleted();
    }
}

/**
 * The main class to store and run the filters. 
 
 */
public class TaskListFilter {
    private ArrayList<TaskFilter> filters;
    private boolean strongFilter; // true for AND/&&, false for OR/||.

    /**
     * @param strongFilter true to use &&/AND filtering, false to use ||/OR filtering. 
     
     */
    public TaskListFilter(boolean strongFilter) {
        this.filters = new ArrayList<TaskFilter>();
        this.strongFilter = strongFilter;
    }

    /**
     * @param filter adds the filter into the list. 
     
     */
    public void add(TaskFilter filter) {
        this.filters.add(filter);
    }

    /**
     * Runs the filters.
     * @param taskList the ArrayList to filter.
     * @return the filtered ArrayList of tasks.
     
     */
    public ArrayList<Task> apply(ArrayList<Task> taskList) {
        ArrayList<Task> filteredTaskList = new ArrayList<Task>();
        ListIterator<Task> taskI = taskList.listIterator();
        ListIterator<TaskFilter> filterI;
        Task task;
        TaskFilter filter;
        boolean keep = this.strongFilter;
        
        while (taskI.hasNext()) {
            task = taskI.next();
            keep = this.strongFilter;
            filterI = this.filters.listIterator();
            while (filterI.hasNext()) {
                filter = filterI.next();
                if (this.strongFilter) { // Strong filter is on, do &&.
                    if (!filter.apply(task)) { // Once false,
                        keep = false; // Do not keep.
                        break; // Get out of the while loop.
                    }
                }
                else { // Strong filter is off, do ||.
                    if (filter.apply(task)) { // Once true,
                        filteredTaskList.add(task);
                        break; // Get out of the while loop.
                    }
                }
            }
            // Only add at this point if it is a strong filter and kept.
            if (this.strongFilter && keep) { filteredTaskList.add(task); }
        }
        
        return filteredTaskList;
    }
}




	// End of segment: .\src\task\TaskListFilter.java





	/**
	 * origin: .\src\task\TaskManager.java
	 */

/**
 * The manager that manipulates and contains the array list of Tasks.
 * 
 */
public class TaskManager {
    public static final char NORMAL_TASK_PREFIX = 'T';
    public static final char DATED_TASK_PREFIX = 'E';
    public static final int DEFAULT_DAYS_TO_DISPLAY = 3;
    
    private ArrayList<Task> list;
    private Task lastModifiedTask;
    private Hashtable<String, Integer> idMapping;
    
    private ListDisplay eventsDisplay;
    private ListDisplay tasksDisplay;
    
    private int daysToDisplay = DEFAULT_DAYS_TO_DISPLAY;
    
    /**
     * Initializes and sets up the task manager.
     */
    public TaskManager() {
        this.idMapping = new Hashtable<String, Integer>();
        this.eventsDisplay = new EventListDisplay();
        this.tasksDisplay = new TaskListDisplay();
    }
    
    /**
     * Sets the number of days to display in the default view.
     * @param days number of days.
     */
    public void setDaysToDisplay(int days) {
        this.daysToDisplay = days;
    }
    
    /**
     * Sets the number of days to display in the default view.
     * @param commandInfo Use start and end time to determine the number of days.
     * @param configManager The config manager to update and save the information to.
     */
    public void setDaysToDisplay(CommandInfo commandInfo, ConfigManager configManager) {
        LocalDate today = new LocalDate();
        LocalDate startDay = new LocalDate();
        if (commandInfo.getStartDateTime() != null) {
            startDay = commandInfo.getStartDateTime().toLocalDate();
        }
        if (startDay.equals(today) && commandInfo.getEndDateTime() != null) {
            LocalDate endDay = commandInfo.getEndDateTime().toLocalDate();
            this.daysToDisplay = Days.daysBetween(startDay, endDay).getDays();
            configManager.setHomeViewType(this.daysToDisplay);
        }
    }
    
    /**
     * Checks if the task displayID entered is valid.
     * 
     * @param displayID the task displayID the user entered.
     * @return whether it exists in idMapping.
     */
    public boolean ensureValidDisplayID(String displayID) {
        return this.idMapping.containsKey(displayID);
    }
    
    /**
     * Used to map displayID to actual taskID.
     * 
     * @param displayID the display ID that is shown in the list view.
     * @return taskID the internal ID of the Task.
     */
    private int mapDisplayIDtoActualID(String displayID) {
        assert(this.idMapping.containsKey(displayID) == true);
        return this.idMapping.get(displayID);
    }
    

    /**
     * Initializes the list of tasks from storage.
     * 
     * @param storedList ArrayList of tasks.
     * @return the initialized list of tasks.
     */
    public ArrayList<Task> initializeList(ArrayList<Task> storedList) {
        list = new ArrayList<Task>(storedList);
        Task.resetIDCounter(list.size());
        return this.list;
    }
    
    /**
     * Returns the last task modified.
     * @return the last task modified.
     */    
    public Task getLastModifiedTask() {
        return this.lastModifiedTask;
    }
    
    
    /**
     * Returns a list of invalid display IDs.
     * @return a list of invalid display IDs, or null if none.
     */
    public ArrayList<String> getInvalidDisplayIDs(ArrayList<String> taskIDs) {
        if (taskIDs == null) { return null; }
        
        ArrayList<String> invalidIDs = new ArrayList<String>();

        ListIterator<String> li = taskIDs.listIterator();
        while (li.hasNext()) {
            String taskID = li.next();
            if (!this.idMapping.containsKey(taskID)) { // Invalid id...
                invalidIDs.add(taskID);
            }
        }
        
        if (invalidIDs.size() == 0) { return null; }
        return invalidIDs;
    }
    
    /**
     * Clears the ID mapping hashtable.
     */
    public void clearIDMapping() { this.idMapping.clear(); }
    
    /**
     * Returns the Task associated with this displayID.
     * @param displayID the displayID of the task.
     * @throws IllegalArgumentException if the displayID is not displayed in the views.
     */
    public Task getTaskFromDisplayID(String displayID) throws IllegalArgumentException {
        if (!this.ensureValidDisplayID(displayID)) {
            throw new IllegalArgumentException("There is no such display ID.");
        }
        return this.list.get(this.mapDisplayIDtoActualID(displayID));
    }
    
    /**
     * Adds a task to the list.
     * 
     * @param commandInfo of type "add".
     */
    public void add(CommandInfo commandInfo) {
        assert(commandInfo.getCommandType() == "add");
        this.lastModifiedTask = new Task(commandInfo);
        this.list.add(this.lastModifiedTask);
    }

    /**
     * Edits a task in the list.
     * 
     * @param commandInfo of type "edit" and contains task id.
     */
    public void edit(CommandInfo commandInfo) {  
        assert(commandInfo.getCommandType() == "edit");
        int taskId = this.mapDisplayIDtoActualID(commandInfo.getTaskIDs().get(0));       
        this.lastModifiedTask = new Task(commandInfo, taskId);
        
        this.list.set(taskId, this.lastModifiedTask); // Replaces the task.
    }

    /**
     * Deletes a task in the list.
     * 
     * @param commandInfo of type "delete" and contains task id(s).
     */
    public void delete(CommandInfo commandInfo) {
        assert(commandInfo.getCommandType() == "delete");
        ListIterator<String> li = commandInfo.getTaskIDs().listIterator();
        while (li.hasNext()) {
            String displayID = li.next();
            int taskId = this.mapDisplayIDtoActualID(displayID);
            this.list.get(taskId).setDeleted(true);
        }
    }
    
    /**
     * Completes a task in the list.
     * 
     * @param commandInfo of type "complete" and contains task id(s).
     */
    public void complete(CommandInfo commandInfo) {   
        assert(commandInfo.getCommandType() == "complete");
        ListIterator<String> li = commandInfo.getTaskIDs().listIterator();
        while (li.hasNext()) {
            String displayID = li.next();
            int taskId = this.mapDisplayIDtoActualID(displayID);
            this.list.get(taskId).complete(); // "Soft-delete" in the ArrayList.
        }
    }

    /**
     * Undos one previous commandInfo.
     * 
     * @param commandInfo of type "undo".
     * @param backup the backup task list.
     */
    public void undo(CommandInfo commandInfo, ArrayList<Task> backup) {
        assert(commandInfo.getCommandType() == "undo");
        this.list = new ArrayList<Task>(backup);
    }
    
    /**
     * Returns the full list of tasks, including the deleted tasks.
     * @return the full list of tasks, including the deleted tasks.
     */
    public ArrayList<Task> getFullList() {
        return this.list;
    }

    /**
     * Returns the full list of tasks, ignoring the deleted tasks.
     * 
     * @return the full list of tasks, ignoring the deleted tasks.
     */
    public ArrayList<Task> getSanitizedList() {
        TaskListFilter filter = new TaskListFilter(true); // Does a AND/&& filtering.
        filter.add(new IgnoreTasksDeleted());
        return filter.apply(this.list);
    }
    
    /**
     * Returns the tasks without start dates.
     * 
     * @return the tasks without start dates.
     */
    public ArrayList<Task> getTasks() {
        TaskListFilter filter = new TaskListFilter(false); // Does a OR/|| filtering.
        filter.add(new KeepTasksCompletedToday()); // or,
        filter.add(new KeepTasksOutstanding());
        filter.add(new KeepReminders());
        filter.add(new KeepTasksBetween(this.daysToDisplay));
        this.tasksDisplay.replaceFilter(filter);
        
        return this.tasksDisplay.display(this.list, this.idMapping);
    }
    
    /**
     * Returns the tasks with start dates.
     * 
     * @return the tasks with start dates.
     */
    public ArrayList<Task> getEvents() {
        TaskListFilter filter = new TaskListFilter(false); // Does a OR/|| filtering.
        filter.add(new KeepTasksCompletedToday()); // or,
        filter.add(new KeepTasksOutstanding());
        filter.add(new KeepTasksBetween(this.daysToDisplay));
        this.eventsDisplay.replaceFilter(filter);
        
        return this.eventsDisplay.display(this.list, this.idMapping);
    }
    
    /**
     * Returns the tasks given in the search parameters.
     * 
     * @return the tasks given in the search parameters.
     */
    public ArrayList<Task> getSearchedTasks(CommandInfo commandInfo) {        
        ArrayList<Comparator<Task>> comparators = new ArrayList<Comparator<Task>>();        
        TaskListFilter filter = new TaskListFilter(true); // AND filter.
        
        // Filtering of dates:
        DateTime start = commandInfo.getStartDateTime();
        DateTime end = commandInfo.getEndDateTime();
        if (start != null && end != null) {
            filter.add(new KeepTasksBetween(start, end));
            comparators.add(new EndDateComparator());
        }
        else if (start != null) { // end is null, not possible here but whatever,
            end = start.withTimeAtStartOfDay().plusDays(1);
            start = start.withTimeAtStartOfDay().minusMillis(1); // Millisecond before today.
            filter.add(new KeepTasksBetween(start, end));
            comparators.add(new EndDateComparator());
        }
        else if (end != null) { // start is null,
            start = new DateTime();
            filter.add(new KeepTasksBetween(start, end));
            comparators.add(new EndDateComparator());
        }

        // Whether to show priority:
        if (commandInfo.getPriority() > 0) {
            filter.add(new KeepTasksWithPriority());
        }
        
        // Whether to show completed only:
        if (commandInfo.isCompleted()) { // For completed tasks only.
            filter.add(new KeepTasksCompleted());
            comparators.add(new CompletedAtComparator());
        }
        
        // Searching by keywords:
        if (commandInfo.getTaskDesc() != null) {
            filter.add(new KeepTasksWithKeyword(commandInfo.getTaskDesc()));
        }
        
        this.tasksDisplay.replaceFilter(filter);
        this.tasksDisplay.replaceComparators(comparators);
        
        return this.tasksDisplay.display(this.list, this.idMapping);
    }
    
    /**
     * Returns the events given in the search parameters.
     * 
     * @return the events given in the search parameters.
     */
    public ArrayList<Task> getSearchedEvents(CommandInfo commandInfo) {
        ArrayList<Comparator<Task>> comparators = new ArrayList<Comparator<Task>>();
        TaskListFilter filter = new TaskListFilter(true); // AND filter.

        // Whether to show completed only:
        if (commandInfo.isCompleted()) { // For completed tasks only.
            filter.add(new KeepTasksCompleted());
            comparators.add(new CompletedAtComparator());
        }
        
        // Whether to show priority, inclusive:
        if (commandInfo.getPriority() > 0) {
            filter.add(new KeepTasksWithPriority());
        }
        
        // Filtering of dates:
        DateTime start = commandInfo.getStartDateTime();
        DateTime end = commandInfo.getEndDateTime();
        if (start != null && end != null) {
            filter.add(new KeepTasksBetween(start, end));
            comparators.add(new DateComparator());
        }
        else if (start != null) { // end is null,
            end = start.withTimeAtStartOfDay().plusDays(1);
            start = start.withTimeAtStartOfDay().minusMillis(1); // Millisecond before today.
            filter.add(new KeepTasksBetween(start, end));
            comparators.add(new DateComparator());
        }
        else if (end != null) { // start is null, not possible here but whatever,
            start = new DateTime();
            filter.add(new KeepTasksBetween(start, end));
            comparators.add(new DateComparator());
        }
        
        // Searching by keywords:
        if (commandInfo.getTaskDesc() != null) {
            filter.add(new KeepTasksWithKeyword(commandInfo.getTaskDesc()));
        }
        
        this.eventsDisplay.replaceFilter(filter);
        this.eventsDisplay.replaceComparators(comparators);
        
        return this.eventsDisplay.display(this.list, this.idMapping);
    }
    
}

	// End of segment: .\src\task\TaskManager.java





	/**
	 * origin: .\test\application\IntegrationTest.java
	 */

/**
 * This class is used to reflect all the private static fields and methods of the Controller class.
 *
 */
class ControllerReflector {
    // Hashtable to map each method and field to their own name.
    public static Hashtable<String, Method> methods = new Hashtable<String, Method>();
    public static Hashtable<String, Field> fields = new Hashtable<String, Field>();

    public static void reflect() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        Class<?> controller = Controller.class;
  
        // Reflects the private static methods.
        Method m[] = controller.getDeclaredMethods();
        for (Method method : m) {
            methods.put(method.getName(), method);
            method.setAccessible(true);
        }
  
        // Reflects the private static fields.
        Field f[] = controller.getDeclaredFields();
        for (Field field : f) {
            fields.put(field.getName(), field);
            field.setAccessible(true);
        }
    }
}

	// End of segment: .\test\application\IntegrationTest.java





	/**
	 * origin: .\test\application\IntegrationTest.java
	 */

/**
 * Mocks the UIComponent class.
 *
 */
public class IntegrationTest extends Application {
    private static final String TODO_TEST_JSON_FILENAME = "Todo.test.json"; // To be used in tests.
    private static final String SAMPLE_TEST_JSON_FILENAME = "SampleTodo.test.json"; // To be loaded in tests.
    private static final Object[] EMPTY = {};
    static UIComponent uiComponent;
    static TaskManager taskManager = new TaskManager();
    static DataStorage dataStorage = new DataStorage(TODO_TEST_JSON_FILENAME);
    static int FIXTURES_SIZE;
    static int TASKS_SIZE;
    static int EVENTS_SIZE;
	static UIAutoComplete autocomplete;
	static UICmdInputBox inputBox;
	static UIAutoCompleteListener acListener;
	
	// End of segment: .\test\application\IntegrationTest.java





	/**
	 * origin: .\test\application\IntegrationTest.java
	 */

    // This is used to set up integration testing.
    // This method will always run once before the tests begin.
    @BeforeClass
    public static void initializeIntegrationTest() throws Exception {
        try {
            ControllerReflector.reflect();
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        // Runs the setup methods to initialize other components.
        ControllerReflector.methods.get("setup").invoke(null, EMPTY);
        
        // Resets the ArrayList of Tasks to empty.
        ArrayList<Task> emptyTasks = new ArrayList<Task>();
        taskManager.initializeList(emptyTasks);
        taskManager.clearIDMapping();
        dataStorage.saveTasks(emptyTasks);
        taskManager.setDaysToDisplay(3);
        
        
        // Replaces the two static fields with our own stubs.
        ControllerReflector.fields.get("taskManager").set(null, taskManager);
        ControllerReflector.fields.get("dataStorage").set(null, dataStorage);
        
        // Run the JavaFX thread in the background.
        Thread t = new Thread("JavaFX Background") {
            @Override
            public void run() {
                launch(IntegrationTest.class);
            }
        };
        t.setDaemon(true);
        t.start();
        
        // Sleeps every half second until uiComponent is set and ready for use.
        int i = 0;
        while (uiComponent == null && i < 6) {
            i++;
            Thread.sleep(500);
        }
    }

	// End of segment: .\test\application\IntegrationTest.java





	/**
	 * origin: .\test\application\IntegrationTest.java
	 */

    // Method to start JavaFX stage during tests.
    @Override
    public void start(Stage primaryStage) throws Exception {
        ControllerReflector.fields.get("uiComponent").set(null, new UIComponent());
        uiComponent = (UIComponent) ControllerReflector.fields.get("uiComponent").get(null);
    }

	// End of segment: .\test\application\IntegrationTest.java





	/**
	 * origin: .\test\application\IntegrationTest.java
	 */

    // This method will be run once before each test.
    @Before
    public void readyTasks() {
		inputBox = new UICmdInputBox(new Text(), new Text(), uiComponent);
		acListener = new UIAutoCompleteListener(inputBox);
		autocomplete = new UIAutoComplete(inputBox, acListener);
		
        DataStorage fixtureStorage = new DataStorage(SAMPLE_TEST_JSON_FILENAME);
        ArrayList<Task> fixtures = fixtureStorage.retrieveTasks();
        taskManager.initializeList(fixtures);
        dataStorage.saveTasks(fixtures);    

        FIXTURES_SIZE = fixtures.size();
        TASKS_SIZE = 3; // Default view to the day itself.
        EVENTS_SIZE = 0; // Default view to the day itself.

        taskManager.setDaysToDisplay(3);
        
        // The following lines readies the hashtable.
        taskManager.clearIDMapping();
        taskManager.getTasks();
        taskManager.getEvents();
        
        /**
         * The fixture contains:
         * ****
         * 
         * Left pane:     
         *   E1: CS2103T Final Exam
         *     !, 26th Nov Wed 13:00 to Wed 15:00
         *     
         *   E2: Christmas shopping
         *     23rd Dec Tues 10:00 to 17:00
         *     
         *   E3: Doctor's appointment
         *     23rd Dec Tues 9:00
         *     
         *   E4: New Year Countdown
         *     31st Dec Wed 22:00
         *     
         * Right pane:
         *   T1: Lucky draw application
         *     by 17th Dec Wed 12:55
         *   T2: Top up ezlink !
         *   T3: Learn new language
         *   T4: Buy new sweater
         *
         */
    }

	// End of segment: .\test\application\IntegrationTest.java





	/**
	 * origin: .\test\application\IntegrationTest.java
	 */

    // This method will be run once after each test.
    @After
    public void clearTasks() {
        // Resets the ArrayList of Tasks to empty.
        ArrayList<Task> emptyTasks = new ArrayList<Task>();
        taskManager.initializeList(emptyTasks);
        dataStorage.saveTasks(emptyTasks);
    }

	// End of segment: .\test\application\IntegrationTest.java





	/**
	 * origin: .\test\application\IntegrationTest.java
	 */

    @Test
    public void testAdd() {
        String commandInput = "add [first wavewave]";
        Controller.runCommandInput(commandInput);
        
        DataStorage checkStorage = new DataStorage(TODO_TEST_JSON_FILENAME);
        
        assertEquals(FIXTURES_SIZE + 1, checkStorage.retrieveTasks().size());
        assertEquals(FIXTURES_SIZE + 1, taskManager.getSanitizedList().size());
        assertEquals(TASKS_SIZE + 1, taskManager.getTasks().size());
        assertEquals(EVENTS_SIZE, taskManager.getEvents().size());
    }

	// End of segment: .\test\application\IntegrationTest.java





	/**
	 * origin: .\test\application\IntegrationTest.java
	 */

    @Test
    public void testAddEmpty() {
        String commandInput = "add []";
        Controller.runCommandInput(commandInput);
        
         assertEquals(FIXTURES_SIZE, taskManager.getSanitizedList().size());
    }

	// End of segment: .\test\application\IntegrationTest.java





	/**
	 * origin: .\test\application\IntegrationTest.java
	 */

    @Test
    public void testCompleteTask() {
        Controller.runCommandInput("show"); // So that all tasks will be shown.
        String commandInput = "complete T2";
        Controller.runCommandInput(commandInput);
        
        assertEquals(TASKS_SIZE, taskManager.getTasks().size());
    }
    
	// End of segment: .\test\application\IntegrationTest.java





	/**
	 * origin: .\test\application\IntegrationTest.java
	 */

    @Test
    public void testDeleteTask() {
        String commandInput = "delete T1";
        Controller.runCommandInput(commandInput);
        
        DataStorage checkStorage = new DataStorage(TODO_TEST_JSON_FILENAME);
        
        assertEquals(FIXTURES_SIZE - 1, checkStorage.retrieveTasks().size());        
        assertEquals(FIXTURES_SIZE - 1, taskManager.getSanitizedList().size());        
    }
    
	// End of segment: .\test\application\IntegrationTest.java





	/**
	 * origin: .\test\task\TaskComparatorTest.java
	 */

public class TaskComparatorTest {

   ArrayList<Task> tasks;
   Task a, b;
   
    @Before
    public void setUp() throws Exception {
        tasks = new ArrayList<Task>();
        a = new Task();
        b = new Task();
        
        tasks.add(a);
        tasks.add(b);
        
        // a comes before b at the moment.
    }

    @After
    public void tearDown() throws Exception {
    }
    
    @Test
    public void testOrderInArrayList() {
        assertEquals("a is in front", a, tasks.get(0));
        assertEquals("b is behind", b, tasks.get(1));
    }

    /**
     * Tests that the start date comparator works as it should.
     */
    @Test
    public void testStartDateComparator() {
        DateTime date = new DateTime(2014, 10, 30, 12, 44, 0); // 30 October 2014, 12:44:00
        a.setDate(date);
        date = date.minusDays(1);
        b.setDate(date);
        
        Collections.sort(tasks, new DateComparator());
        
        assertEquals("b is now in front", b, tasks.get(0));
        assertEquals("a is now behind", a, tasks.get(1));
    }
    
    /**
     * Tests that the end date comparator works as it should. 
     */
    @Test
    public void testEndDateComparator() {
        DateTime date = new DateTime(2014, 10, 30, 12, 44, 0); // 30 October 2014, 12:44:00
        a.setDate(date);
        b.setDate(date);

        date = date.plusDays(3);
        a.setEndDate(date);
        date = date.minusDays(1);
        b.setEndDate(date);
        
        Collections.sort(tasks, new DateComparator());

        assertEquals("a is now behind", a, tasks.get(1));
        assertEquals("b is now in front", b, tasks.get(0));
    }
    
    /**
     * Tests that the priority comparator works as it should.
     */
    @Test
    public void testPriorityComparator() {
        a.setPriority(0);
        b.setPriority(1);
        
        Collections.sort(tasks, new PriorityComparator());
        
        assertEquals("b is now in front", b, tasks.get(0));
        assertEquals("a is now behind", a, tasks.get(1));        
    }
    
    /**
     * Tests that the modified at comparator works as it should.
     */
    @Test
    public void testModifiedAtComparator() {
        try {
            Thread.sleep(100); // So that modified at time is significantly different.
        } catch (Exception e) {}
        
        b.setPriority(0); // So that b is "updated".
        
        Collections.sort(tasks, new ModifiedAtComparator());
        
        assertEquals("b is now in front", b, tasks.get(0));
        assertEquals("a is now behind", a, tasks.get(1));        
    }

}

	// End of segment: .\test\task\TaskComparatorTest.java





	/**
	 * origin: .\test\task\TaskTest.java
	 */

/**
 *
 */
public class TaskTest {
    private Task task;

    @Before
    public void setUp() {
        task = new Task();
    }

    @After
    public void tearDown() {
    }

    /**
     * Test method for {@link task.Task#getID()}.
     */
    @Test
    public void testGetId() {
        assertNotNull(task.getID());
    }
    
    /**
     * Test method for {@link task.Task#displayID()}.
     */
    @Test
    public void testDisplayId() {
        assertNull("has null displayID", task.getDisplayID());
        
        String displayID = "F1";
        task.setDisplayID(displayID);
        assertEquals("has set displayID", displayID, task.getDisplayID());
    }

    /**
     * Test method for {@link task.Task#description}.
     */
    @Test
    public void testDescription() {
        assertNull("has null description", task.getDescription());
        
        String description = "description";
        task.setDescription(description);
        assertEquals("has set description", description, task.getDescription());
    }

    /**
     * Test method for {@link task.Task#date}.
     */
    @Test
    public void testDate() {
        assertNull("has null date", task.getDate());
        
        DateTime date = new DateTime(2014, 10, 11, 12, 44, 0);
        task.setDate(date);
        assertEquals("has set date", date, task.getDate());
        
        task.setDate(null);
        assertNull("has set null date", task.getDate());
    }

    /**
     * Test method for {@link task.Task#endDate}.
     */
    @Test
    public void testEndDate() {
        assertNull("has null endDate", task.getEndDate());
        
        DateTime endDate = new DateTime(2014, 10, 11, 12, 44, 0);
        task.setEndDate(endDate);
        assertEquals("has set endDate", endDate, task.getEndDate());
        
        task.setEndDate(null);
        assertNull("has set null endDate", task.getEndDate());
    }

    /**
     * Test method for {@link task.Task#completed}.
     */
    @Test
    public void testCompleted() {
        assertFalse("is not completed", task.isCompleted());
        
        task.complete();
        assertTrue("is completed", task.isCompleted());
        
        task.setCompleted(false);
        assertFalse("is not completed again", task.isCompleted());
    }

    /**
     * Test method for {@link task.Task#priority}.
     */
    @Test
    public void testPriority() {
        assertEquals("has no priority", task.getPriority(), 0);
        
        int priority = 1;
        task.setPriority(priority);
        assertEquals("has priority", priority, task.getPriority());        
    }

}

	// End of segment: .\test\task\TaskTest.java





